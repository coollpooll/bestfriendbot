import os
import logging
import re
import base64
import httpx
import datetime
import asyncio
from io import BytesIO
from aiogram import Bot, Dispatcher, types, F
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.filters import CommandStart
from aiogram.enums import ParseMode
from aiogram.client.bot import DefaultBotProperties
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from dotenv import load_dotenv
import asyncpg
from fastapi import FastAPI, Request
from openai import OpenAI
from pydub import AudioSegment
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from PIL import Image
import io

# –ò–º–ø–æ—Ä—Ç—ã –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
import mimetypes
import zipfile
import rarfile

from PyPDF2 import PdfReader
from docx import Document as DocxDocument
import csv
import pandas as pd
import pptx
import xlrd
import openpyxl
import textract

load_dotenv()

logging.basicConfig(level=logging.INFO)

BOT_TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
ASSISTANT_ID = os.getenv("ASSISTANT_ID")
DATABASE_URL = os.getenv("DATABASE_URL")
OWNER_CHAT_ID = int(os.getenv("OWNER_CHAT_ID"))

# Replicate API –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–æ—Ç–æ
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")

bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
app = FastAPI()
openai_client = OpenAI(api_key=OPENAI_API_KEY)

# --- –ü–æ–∏—Å–∫ Google AI Overview —á–µ—Ä–µ–∑ SerpAPI (–æ—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ —Å–ª—É—á–∞–π fallback, –Ω–æ —Ä–µ–∞–ª—å–Ω–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è) ---
async def google_ai_search(query):
    return None  # –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–≤–æ–π –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞ –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –∑–∞–≥–ª—É—à–∫—É

# --- Database logic
class Database:
    def __init__(self, dsn):
        self.dsn = dsn
        self.pool = None

    async def connect(self):
        self.pool = await asyncpg.create_pool(self.dsn)

    async def disconnect(self):
        if self.pool:
            await self.pool.close()

    async def add_user(self, user_id):
        async with self.pool.acquire() as connection:
            await connection.execute(
                "INSERT INTO users (user_id, requests_today) VALUES ($1, $2) ON CONFLICT (user_id) DO NOTHING",
                user_id, 0
            )

    async def add_message(self, user_id, role, content):
        async with self.pool.acquire() as connection:
            await connection.execute(
                "INSERT INTO dialog_history (user_id, role, content) VALUES ($1, $2, $3)",
                user_id, role, content
            )

    async def get_history(self, user_id, limit=16):
        async with self.pool.acquire() as connection:
            rows = await connection.fetch(
                """
                SELECT role, content FROM dialog_history
                WHERE user_id = $1
                ORDER BY created_at DESC
                LIMIT $2
                """,
                user_id, limit
            )
            return [{"role": row["role"], "content": row["content"]} for row in reversed(rows)]

    async def add_subscription(self, user_id, plan, payment_id):
        async with self.pool.acquire() as connection:
            if plan == 'monthly':
                expires_at = "NOW() + INTERVAL '30 days'"
            elif plan == 'yearly':
                expires_at = "NOW() + INTERVAL '365 days'"
            else:
                raise ValueError("Unknown plan type")
            await connection.execute(
                f"""
                INSERT INTO subscriptions 
                    (user_id, plan, started_at, expires_at, payment_id, status) 
                VALUES 
                    ($1, $2, NOW(), {expires_at}, $3, 'active')
                """,
                user_id, plan, payment_id
            )

    async def get_user_subscription(self, user_id):
        async with self.pool.acquire() as connection:
            row = await connection.fetchrow(
                """
                SELECT plan, expires_at FROM subscriptions
                WHERE user_id = $1 AND status = 'active' AND expires_at > NOW()
                ORDER BY expires_at DESC
                LIMIT 1
                """,
                user_id
            )
            return row

    async def get_stats(self):
        async with self.pool.acquire() as connection:
            users = await connection.fetchval("SELECT COUNT(*) FROM users")
            monthly = await connection.fetchval(
                "SELECT COUNT(*) FROM subscriptions WHERE plan = 'monthly' AND status = 'active'")
            yearly = await connection.fetchval(
                "SELECT COUNT(*) FROM subscriptions WHERE plan = 'yearly' AND status = 'active'")
            return users, monthly, yearly

db = Database(DATABASE_URL)

def get_main_keyboard(user_id):
    buttons = [
        [KeyboardButton(text="–ü–û–ú–û–©–¨"), KeyboardButton(text="–ü–û–î–ü–ò–°–ö–ê")],
        [KeyboardButton(text="–†–ï–î–ê–ö–¢–ò–†–û–í–ê–¢–¨ –§–û–¢–û")]  # –ù–û–í–ê–Ø –ö–ù–û–ü–ö–ê
    ]
    if user_id == OWNER_CHAT_ID:
        buttons[0].append(KeyboardButton(text="–ê–î–ú–ò–ù"))
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)

@dp.message(CommandStart())
async def cmd_start(message: types.Message):
    await db.add_user(message.from_user.id)
    keyboard = get_main_keyboard(message.from_user.id)
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π BEST FRIEND ü§ñ\n–ì–æ—Ç–æ–≤ –ø–æ–º–æ—á—å —Å –ª—é–±—ã–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏!",
        reply_markup=keyboard
    )

@dp.message(F.text.lower() == "–ø–æ–º–æ—â—å")
async def help_command(message: types.Message):
    help_text = (
        "<b>ü§ñ BEST FRIEND: –ü—Ä–∞–≤–∏–ª–∞ –∏ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏</b>\n\n"
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ª–∏—á–Ω—ã–π –ò–ò-–±–æ—Ç –¥–ª—è –∂–∏–∑–Ω–∏, –±–∏–∑–Ω–µ—Å–∞, –æ–±—É—á–µ–Ω–∏—è, —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–∞, —Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è –∏ –Ω–µ —Ç–æ–ª—å–∫–æ. –í–æ—Ç —á—Ç–æ —è —É–º–µ—é:\n\n"
        "<b>‚öôÔ∏è –ú–æ–π –¥–≤–∏–∂–æ–∫ (—á—Ç–æ –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º):</b>\n\n"
        "    <b>GPT-4o</b> ‚Äî —Ç–æ–ø–æ–≤–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å –æ—Ç OpenAI, –ø–æ–Ω–∏–º–∞–µ—Ç –∏ –ø–∏—à–µ—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º, –ø–æ–º–Ω–∏—Ç —Ç–≤–æ–π –¥–∏–∞–ª–æ–≥, –≥–µ–Ω–∏–∞–ª—å–Ω–∞ –ø–æ—á—Ç–∏ –≤–æ –≤—Å—ë–º (–≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ä–∞–∑—É–º–Ω–æ–≥–æ)!\n\n"
        "    <b>DALL-E 3</b> ‚Äî –Ω–µ–π—Ä–æ—Å–µ—Ç—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫. –ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å: <i>‚Äú–Ω–∞—Ä–∏—Å—É–π —Ç–∏–≥—Ä–∞ –≤ –æ—á–∫–∞—Ö‚Äù</i> –∏ –ø–æ–ª—É—á–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è!\n\n"
        "    <b>GPT-4o Vision</b> ‚Äî —Ä–∞—Å–ø–æ–∑–Ω–∞—ë—Ç –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ñ–æ—Ç–æ –∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏. –ü—Ä–∏—Å—ã–ª–∞–π —Ñ–æ—Ç–∫–∏ ‚Äî —Ä–∞—Å—Å–∫–∞–∂—É, —á—Ç–æ –Ω–∞ –Ω–∏—Ö.\n\n"
        "    <b>Whisper</b> ‚Äî –ø–µ—Ä–µ–≤–æ–∂—É —Ç–≤–æ–∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ –≤ —Ç–µ–∫—Å—Ç. –•–æ—á–µ—à—å –ø–æ–≥–æ–≤–æ—Ä–∏—Ç—å ‚Äî –∑–∞–ø–∏—Å—ã–≤–∞–π –∞—É–¥–∏–æ.\n\n"
        "<b>üìÑ –ß—Ç–æ –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å:</b>\n\n"
        "    üìù <b>–¢–µ–∫—Å—Ç–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã</b> (–¥–∏–∞–ª–æ–≥–∏, —Å—Ç–∞—Ç—å–∏, –ø–µ—Ä–µ–≤–æ–¥—ã, —Å—Ç–∏—Ö–∏, –∏–¥–µ–∏, –∫–æ–¥—ã –∏ —Ç.–¥.)\n\n"
        "    üé§ <b>–ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b> ‚Äî –≤—Å—ë –ø–æ–π–º—É, –ø–µ—Ä–µ–≤–µ–¥—É –≤ —Ç–µ–∫—Å—Ç, –æ—Ç–≤–µ—á—É.\n\n"
        "    üñºÔ∏è <b>–ö–∞—Ä—Ç–∏–Ω–∫–∏ –∏ —Ñ–æ—Ç–æ</b> ‚Äî –ø—Ä–∏—à–ª–∏, –∏ —è –æ–ø–∏—à—É, —á—Ç–æ –Ω–∞ –Ω–∏—Ö, –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É—é –Ω–æ–≤—ã–µ –ø–æ —Ç–≤–æ–µ–º—É –æ–ø–∏—Å–∞–Ω–∏—é.\n\n"
        "    üìö <b>–§–∞–π–ª—ã –∏ –¥–æ–∫—É–º–µ–Ω—Ç—ã</b> ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è PDF, Word, Excel, PowerPoint, txt, csv, zip, rar –∏ –º–Ω–æ–≥–∏–µ –¥—Ä—É–≥–∏–µ! –Ø —á–∏—Ç–∞—é, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é (–¥–æ 4000 —Å–∏–º–≤–æ–ª–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞).\n\n"
        "<b>üö¶ –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:</b>\n\n"
        "    <b>–ü–∏—à–∏ –∏–ª–∏ –≥–æ–≤–æ—Ä–∏</b> ‚Äî –ø—Ä–æ—Å—Ç–æ —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å, –ø—Ä–æ—Å—å–±—É –∏–ª–∏ –∑–∞–¥–∞—á—É. –ù–∞–ø—Ä–∏–º–µ—Ä, - \"—Å–æ—Å—Ç–∞–≤—å –∫—É—Ä—Å –æ–±—É—á–µ–Ω–∏—è –ø–æ...\"\n\n"
        "    <b>–î–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫</b> ‚Äî –Ω–∞—á–∏–Ω–∞–π —Å ¬´–Ω–∞—Ä–∏—Å—É–π¬ª, ¬´—Å–æ–∑–¥–∞–π¬ª, ¬´—Å–¥–µ–ª–∞–π –∫–∞—Ä—Ç–∏–Ω–∫—É‚Ä¶¬ª (–∏–ª–∏ –ø–∏—à–∏ –ø–æ-–∞–Ω–≥–ª–∏–π—Å–∫–∏: generate, draw‚Ä¶).\n\n"
        "    <b>–î–ª—è —Ñ–∞–π–ª–æ–≤</b> ‚Äî –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–π –¥–æ–∫—É–º–µ–Ω—Ç, –±–æ—Ç —Å–∞–º —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—Ç —Ç–∏–ø –∏ –≤—ã—Ç–∞—â–∏—Ç —Ç–µ–∫—Å—Ç.\n\n"
        "<b>üìé –§–æ—Ä–º–∞—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤:</b>\n\n"
        "    –ï—Å–ª–∏ —Ç–≤–æ–π –æ—Ç–≤–µ—Ç –±–æ–ª—å—à–æ–π –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–¥ ‚Äî –ø—Ä–∏–ª–µ—Ç–∏—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ñ–∞–π–ª–æ–º.\n\n"
        "    –ì–æ–ª–æ—Å–æ–≤—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑—É—é –≤ —Ç–µ–∫—Å—Ç –∏ –æ—Ç–≤–µ—á–∞—é —Ç—É—Ç –∂–µ.\n\n"
        "    –ù–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞—Ö –æ—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–æ—Ç–æ/–∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏—é.\n\n"
        "    –ù–∞ —Ñ–∞–π–ª–∞—Ö ‚Äî —Ä–∞—Å–ø–æ–∑–Ω–∞—é –∏ –¥–∞—é —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Ä–µ–∑—é–º–µ.\n\n"
        "<b>üö´ <u>–ü—Ä–∞–≤–∏–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:</u></b>\n\n"
        "    –ù–µ —Ñ–ª—É–¥–∏ ‚Äî –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ.\n\n"
        "    –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–π –∑–∞–ø—Ä–µ—â—ë–Ω–∫—É: –ø–æ—Ä–Ω–æ–≥—Ä–∞—Ñ–∏—é, —É–≥—Ä–æ–∑—ã, –Ω–∞—Ä–∫–æ—Ç–∏–∫–∏, –ø–æ–ø—ã—Ç–∫–∏ –≤–∑–ª–æ–º–∞, —Å–ø–∞–º –∏ —Ç.–¥.\n\n"
        "    –£–≤–∞–∂–∞–π –¥—Ä—É–≥–∏—Ö ‚Äî –±–æ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏—è –∏ —Ç—Ä–∞–≤–ª—é.\n\n"
        "    –ò—Å–ø–æ–ª—å–∑—É–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –ø–æ–ª—å–∑—ã, –∂–∏–∑–Ω–∏, –±–∏–∑–Ω–µ—Å–∞, —É—á—ë–±—ã, –ª–∏—á–Ω–æ—Å—Ç–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞.\n\n"
        "    <b>–ü–æ–¥–ø–∏—Å–∫–∞</b> –¥–∞—ë—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π. –û—Ñ–æ—Ä–º–∏—Ç—å/–ø—Ä–æ–¥–ª–∏—Ç—å –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –ü–û–î–ü–ò–°–ö–ê.\n\n"
        "<b>ü§™ –ù–µ–º–Ω–æ–≥–æ —é–º–æ—Ä–∞:</b>\n"
        "–ù–µ —Å—Ç–µ—Å–Ω—è–π—Å—è —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å ‚Äî —è –Ω–µ –ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç, –Ω–æ –º–æ–≥—É –ø–æ—Å–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å, —Ä–∞—Å—Å–º–µ—à–∏—Ç—å, –ø–æ–¥–±–æ–¥—Ä–∏—Ç—å –∏ –¥–∞–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Å–ª–æ–Ω–∞ –≤ —à–ª—è–ø–µ –∏–ª–∏ —à–ª—è–ø—É —Å–ª–æ–Ω–∞.\n"
        "–ï—Å–ª–∏ —á—Ç–æ-—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ ‚Äú–ø–æ—á–µ–º—É —Ç—ã —Ç—É–ø–∏—à—å?‚Äù –∏–ª–∏ ‚Äú–∞–¥–º–∏–Ω‚Äù, –∏ —Ç–µ–±—è –ø–æ–π–º—É—Ç :)\n\n"
        "<b>üí° –ó–∞–ø–æ–º–Ω–∏:</b>\n"
        "–Ø –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å —Ç–≤–æ—é –∂–∏–∑–Ω—å –ø—Ä–æ—â–µ, –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ –∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–µ–µ. –í—Å—ë, —á—Ç–æ —Ç—ã –ø–∏—à–µ—à—å, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –ò–ò. –ù–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞–π –±–æ—Ç –∑–∞–¥–∞—á–∞–º–∏ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –º–∏—Ä–æ–≤–æ–≥–æ –≥–æ—Å–ø–æ–¥—Å—Ç–≤–∞ ‚Äî —É –º–µ–Ω—è –ª–∏–º–∏—Ç –ø–æ —ç–ª–µ–∫—Ç—Ä–æ—Å–µ—Ç–∏ üòè\n\n"
        "<b>üëë –í—Å–µ –≤–æ–ø—Ä–æ—Å—ã, –ø–æ–∂–µ–ª–∞–Ω–∏—è –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è ‚Äî –≤—Å–µ–≥–¥–∞ –æ—Ç–∫—Ä—ã—Ç –∫ –∞–ø–≥—Ä–µ–π–¥—É! –Ø –æ–±—É—á–∞—é—Å—å –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ</b>\n\n"
        "–ï—Å–ª–∏ —á—Ç–æ-—Ç–æ —É–ø—É—Å—Ç–∏–ª ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–ø—Ä–æ–±—É–π, –∏ —Ç—ã —É–≤–∏–¥–∏—à—å, –Ω–∞ —á—Ç–æ —è —Å–ø–æ—Å–æ–±–µ–Ω!\n"
        "–¢–≤–æ–π <b>BEST FRIEND</b> ü§ñ"
    )
    await message.answer(help_text, reply_markup=get_main_keyboard(message.from_user.id))


@dp.message(F.text.lower() == "–ø–æ–¥–ø–∏—Å–∫–∞")
async def sub_command(message: types.Message):
    sub_url = "https://your-payment-link.com"
    user_id = message.from_user.id
    sub = await db.get_user_subscription(user_id)
    if sub is None:
        text = (
            "üòî <b>–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞</b>\n\n"
            "–û—Ñ–æ—Ä–º–∏ –ø–æ–¥–ø–∏—Å–∫—É, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø:\n"
            f"<a href=\"{sub_url}\">–û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É</a>"
        )
    else:
        expires = sub["expires_at"].strftime("%d.%m.%Y %H:%M")
        text = (
            f"‚úÖ <b>–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ: {expires}</b>\n\n"
            "–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É:\n"
            f"<a href=\"{sub_url}\">–û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É</a>"
        )
    await message.answer(
        text,
        disable_web_page_preview=True,
        reply_markup=get_main_keyboard(user_id)
    )

@dp.message(F.text.lower() == "–∞–¥–º–∏–Ω")
async def admin_stats(message: types.Message):
    if message.from_user.id != OWNER_CHAT_ID:
        return
    users, monthly, yearly = await db.get_stats()
    msg = (
        f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ üëë</b>\n"
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>{users}</b>\n"
        f"–ú–µ—Å—è—á–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫: <b>{monthly}</b>\n"
        f"–ì–æ–¥–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫: <b>{yearly}</b>"
    )
    await message.answer(msg, reply_markup=get_main_keyboard(message.from_user.id))

@app.on_event("startup")
async def on_startup():
    await db.connect()
    logging.info("Database connected")
    await bot.delete_my_commands()

@app.on_event("shutdown")
async def on_shutdown():
    await db.disconnect()
    logging.info("Database disconnected")

@app.post("/webhook")
async def telegram_webhook(request: Request):
    body = await request.json()
    update = types.Update(**body)
    await dp.feed_update(bot, update)
    return {"ok": True}

IMAGE_KEYWORDS = [
    r"^(–Ω–∞—Ä–∏—Å—É–π|—Å–æ–∑–¥–∞–π|—Å–¥–µ–ª–∞–π|—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π)\s*(–∫–∞—Ä—Ç–∏–Ω–∫—É|–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)?",
    r"^(generate|draw|create|make)\s*(image|picture)?",
]

# ---------- FSM –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–æ—Ç–æ ----------------
class EditPhoto(StatesGroup):
    waiting_for_photo = State()
    waiting_for_edit_prompt = State()

@dp.message(F.text.lower() == "—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ")
async def edit_photo_start(message: types.Message, state: FSMContext):
    await message.answer("–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—á–µ—à—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å üì∏", reply_markup=get_main_keyboard(message.from_user.id))
    await state.set_state(EditPhoto.waiting_for_photo)

@dp.message(EditPhoto.waiting_for_photo, F.photo)
async def receive_photo_for_edit(message: types.Message, state: FSMContext):
    photo = message.photo[-1]
    file = await bot.get_file(photo.file_id)
    photo_bytes_io = BytesIO()
    await bot.download_file(file.file_path, destination=photo_bytes_io)
    photo_bytes = photo_bytes_io.getvalue()
    if not photo_bytes:
        await message.answer("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª. –ü—Ä–∏—à–ª–∏ –¥—Ä—É–≥–æ–µ —Ñ–æ—Ç–æ.")
        return
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ç–æ –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å—Ç–µ–π—Ç
    await state.update_data(photo=photo_bytes)
    await message.answer("–ß—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞ —Ñ–æ—Ç–æ? –û–ø–∏—à–∏ —Ç–µ–∫—Å—Ç–æ–º.", reply_markup=get_main_keyboard(message.from_user.id))
    await state.set_state(EditPhoto.waiting_for_edit_prompt)

@dp.message(EditPhoto.waiting_for_photo)
async def wrong_content_photo(message: types.Message, state: FSMContext):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ (—Ñ–∞–π–ª, –Ω–µ —Å—Ç–∏–∫–µ—Ä)", reply_markup=get_main_keyboard(message.from_user.id))

@dp.message(EditPhoto.waiting_for_edit_prompt, F.text)
async def process_edit_prompt(message: types.Message, state: FSMContext):
    data = await state.get_data()
    photo_bytes = data.get("photo")
    prompt = message.text.strip()
    await message.answer("–ì–æ—Ç–æ–≤–ª—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∂–¥–∏ 10-30 —Å–µ–∫... üòé", reply_markup=get_main_keyboard(message.from_user.id))
    try:
        image_url = await run_replicate_edit(photo_bytes, prompt)
        await message.answer_photo(image_url, caption="–ì–æ—Ç–æ–≤–æ! –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –µ—â—ë ‚Äî –∑–∞–≥—Ä—É–∑–∏ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ.", reply_markup=get_main_keyboard(message.from_user.id))
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {e}", reply_markup=get_main_keyboard(message.from_user.id))
    finally:
        await state.clear()

@dp.message(EditPhoto.waiting_for_edit_prompt)
async def wrong_content_prompt(message: types.Message, state: FSMContext):
    await message.answer("–û–ø–∏—à–∏ —Å–ª–æ–≤–∞–º–∏, —á—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞ —Ñ–æ—Ç–æ.")

# ----------- –§—É–Ω–∫—Ü–∏—è –¥–ª—è Replicate (edit) ----------
async def run_replicate_edit(photo_bytes, prompt):
    api_token = REPLICATE_API_TOKEN
    url = "https://api.replicate.com/v1/predictions"
    img_b64 = base64.b64encode(photo_bytes).decode("utf-8")
    headers = {
        "Authorization": f"Token {api_token}",
        "Content-Type": "application/json"
    }
    payload = {
        "version": "a9758cb2b7029bb98c8e5894e6c1c6249cf77cb511b4cc1e2c0d681fa830965c",  # SDXL 1.0
        "input": {
            "image": f"data:image/png;base64,{img_b64}",
            "prompt": prompt
        }
    }
    async with httpx.AsyncClient(timeout=120) as client:
        resp = await client.post(url, headers=headers, json=payload)
        if resp.status_code != 201:
            raise Exception(f"Replicate error: {resp.status_code}, {resp.text}")
        prediction = resp.json()
        prediction_url = prediction["urls"]["get"]
        while True:
            r = await client.get(prediction_url, headers=headers)
            output = r.json()
            status = output["status"]
            if status == "succeeded":
                return output["output"][0]
            elif status in ["failed", "canceled"]:
                raise Exception("Replicate: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å.")
            await asyncio.sleep(2)

# ------------------------------------------------------

@dp.message(F.text)
async def universal_image_handler(message: types.Message):
    await handle_text_or_image(message, message.text)

def should_send_as_file(text):
    if re.search(r"```.*?```", text, re.DOTALL):
        return True
    if re.match(r"^\s*(def |class |import |from |#|\/\/|<\w+)", text.strip()):
        return True
    lines = text.strip().split("\n")
    if len(lines) > 8 and any(sym in lines[0] for sym in ("def", "class", "import", "from", "#", "//", "<")):
        return True
    if re.search(r"(def |class |import |from |#|\/\/|<\w+)", text):
        return True
    return False

async def generate_filename(prompt, answer):
    system_prompt = (
        "–¢—ã –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è Telegram. –ù–∞ –≤—Ö–æ–¥–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –∏ —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞ —Å –∫–æ–¥–æ–º. "
        "–í–µ—Ä–Ω–∏ –¢–û–õ–¨–ö–û –∫–æ—Ä–æ—Ç–∫–æ–µ –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–±–µ–∑ –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞), –Ω–µ –±–æ–ª–µ–µ 3 —Å–ª–æ–≤, —á–µ—Ä–µ–∑ –Ω–∏–∂–Ω–µ–µ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏–µ, –≤—Å–µ–≥–¥–∞ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .txt, "
        "–ø—Ä–∏–º–µ—Ä: snake_game.txt, telegram_bot.txt, sql_export_script.txt"
    )
    response = openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": f"–ó–∞–ø—Ä–æ—Å: {prompt}\n–û—Ç–≤–µ—Ç:\n{answer}\n"},
        ],
        max_tokens=20,
        temperature=0.1
    )
    name = response.choices[0].message.content.strip()
    if not name.endswith(".txt"):
        name = "answer.txt"
    return name

def is_time_question(text):
    text = text.lower()
    return bool(re.search(r"\b(–≤—Ä–µ–º—è|—á–∞—Å|time)\b", text))

# –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ (—Ç–µ–∫—Å—Ç/–≥–æ–ª–æ—Å)
async def handle_text_or_image(message, text):
    user_id = message.from_user.id
    t = text.strip().lower()
    if t in ["–ø–æ–º–æ—â—å", "–ø–æ–¥–ø–∏—Å–∫–∞", "–∞–¥–º–∏–Ω", "—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ"]:
        return
    for pattern in IMAGE_KEYWORDS:
        m = re.match(pattern, t)
        if m:
            desc = re.sub(pattern, '', text, count=1).strip(":,. \n")
            if not desc:
                await message.answer("–û–ø–∏—à–∏, —á—Ç–æ –Ω—É–∂–Ω–æ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å üë©‚Äçüé®", reply_markup=get_main_keyboard(user_id))
                return
            try:
                response = openai_client.images.generate(
                    model="dall-e-3",
                    prompt=desc,
                    n=1,
                    size="1024x1024"
                )
                image_url = response.data[0].url
                await message.answer_photo(image_url, caption="–ì–æ—Ç–æ–≤–æ! –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –µ—â—ë ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å.", reply_markup=get_main_keyboard(user_id))
            except Exception as e:
                await message.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏ üòî", reply_markup=get_main_keyboard(user_id))
            return
    if is_time_question(text):
        now = datetime.datetime.now().strftime("%H:%M:%S")
        await message.answer(f"–°–µ–π—á–∞—Å {now}", reply_markup=get_main_keyboard(user_id))
        return

    await db.add_message(user_id, "user", text)
    history = await db.get_history(user_id, limit=16)
    try:
        gpt_response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=history,
        )
        answer = gpt_response.choices[0].message.content

        SEARCH_TRIGGERS = [
            "–Ω–µ –∏–º–µ—é –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç–µ–∫—É—â–µ–º—É –≤—Ä–µ–º–µ–Ω–∏",
            "–Ω–µ –∏–º–µ—é –¥–æ—Å—Ç—É–ø–∞ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
            "—è –Ω–µ –º–æ–≥—É —É–∑–Ω–∞—Ç—å",
            "—è –Ω–µ –∑–Ω–∞—é",
            "—è –Ω–µ –æ–±–ª–∞–¥–∞—é –∞–∫—Ç—É–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π",
            "–º–æ—è –±–∞–∑–∞ —É—Å—Ç–∞—Ä–µ–ª–∞",
            "–Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å",
            "—É –º–µ–Ω—è –Ω–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏",
            "–ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—é –Ω–∞",
            "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é",
            "–º–æ—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏",
            "–≤—ã –º–æ–∂–µ—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å",
            "—è –Ω–µ –º–æ–≥—É –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É"
        ]

        if any(x in answer.lower() for x in SEARCH_TRIGGERS):
            answer = "–Ø –Ω–µ –Ω–∞—à—ë–ª —Å–≤–µ–∂–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ —Ç–≤–æ–µ–º—É –∑–∞–ø—Ä–æ—Å—É."

        await db.add_message(user_id, "assistant", answer)

        if should_send_as_file(answer):
            file_name = await generate_filename(text, answer)
            with open(file_name, "w", encoding="utf-8") as f:
                f.write(answer)
            with open(file_name, "rb") as f:
                await message.answer_document(types.BufferedInputFile(f.read(), file_name), caption="–ì–æ—Ç–æ–≤–æ! –í–æ—Ç —Ç–≤–æ–π —Ñ–∞–π–ª üëá", reply_markup=get_main_keyboard(user_id))
            os.remove(file_name)
        else:
            await message.answer(answer, reply_markup=get_main_keyboard(user_id))
    except Exception:
        await message.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò ü§ñ", reply_markup=get_main_keyboard(user_id))

# ------- –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (Whisper + GPT-4o + –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞—Ä—Ç–∏–Ω–æ–∫) --------
@dp.message(F.voice)
async def handle_voice(message: types.Message):
    user_id = message.from_user.id
    file_id = message.voice.file_id
    file = await bot.get_file(file_id)
    ogg_path = f"voice_{user_id}.ogg"
    wav_path = f"voice_{user_id}.wav"
    await bot.download_file(file.file_path, ogg_path)
    try:
        audio = AudioSegment.from_file(ogg_path, format="ogg")
        audio.export(wav_path, format="wav")
    except Exception:
        await message.answer("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ üò¢", reply_markup=get_main_keyboard(user_id))
        return
    try:
        with open(wav_path, "rb") as audio_file:
            transcript = openai_client.audio.transcriptions.create(
                model="whisper-1",
                file=audio_file,
                response_format="text",
                language="ru"
            )
        user_text = transcript.text if hasattr(transcript, "text") else str(transcript)
    except Exception:
        await message.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ üòî", reply_markup=get_main_keyboard(user_id))
        return
    finally:
        try:
            os.remove(ogg_path)
            os.remove(wav_path)
        except Exception:
            pass
    await handle_text_or_image(message, user_text)

# ------- –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (GPT-4o Vision) --------
@dp.message(F.photo)
async def handle_photo(message: types.Message):
    pass  # –∑–¥–µ—Å—å —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ –∏–ª–∏ –Ω–∏—á–µ–≥–æ, –µ—Å–ª–∏ FSM

# ------- –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–º—É–ª—å—Ç–∏—Ç—Ä–∏–≥–µ—Ä) --------
@dp.message(F.document)
async def handle_document(message: types.Message):
    pass  # –∑–¥–µ—Å—å —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ –∏–ª–∏ –Ω–∏—á–µ–≥–æ, –µ—Å–ª–∏ FSM

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=10000)










































