import os
from openai import OpenAI
from fastapi import FastAPI, Request
from pydantic import BaseModel
import httpx
from serpapi import GoogleSearch
from databases import Database
from datetime import datetime, timezone
import hmac
import hashlib

app = FastAPI()

BOT_TOKEN = "7699903458:AAEGl6YvcYpFTFh9-D61JSYeWGA9blqiOyc"
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
ASSISTANT_ID = "asst_uPuKSO4il3oJodGZUsLWH974"
SERPAPI_KEY = "292bb3653ec4db2e9abc418bc91548b1fec768997bf9f1aec3937f426272ae29"
CLOUDPAYMENTS_SECRET = os.getenv("CLOUDPAYMENTS_SECRET", "your_cloudpayments_secret_key")
DATABASE_URL = "postgresql://bestfriend_db_user:Cm0DfEpdc2wvTPqrFd29ArMyJY4XYh5C@dpg-d0rmt7h5pdvs73a6h9m0-a/bestfriend_db"
TELEGRAM_API = f"https://api.telegram.org/bot{BOT_TOKEN}"

client = OpenAI(api_key=OPENAI_API_KEY)
database = Database(DATABASE_URL)
usage_counter = {}
chat_histories = {}

@app.on_event("startup")
async def startup():
    await database.connect()
    await database.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            chat_id TEXT UNIQUE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    """)
    await database.execute("""
        CREATE TABLE IF NOT EXISTS subscriptions (
            id SERIAL PRIMARY KEY,
            chat_id TEXT UNIQUE,
            is_active BOOLEAN DEFAULT FALSE,
            expires_at TIMESTAMP,
            transaction_id TEXT,
            payment_method TEXT
        );
    """)
    await database.execute("""
        CREATE TABLE IF NOT EXISTS usage_log (
            id SERIAL PRIMARY KEY,
            chat_id TEXT,
            used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    """)

@app.on_event("shutdown")
async def shutdown():
    await database.disconnect()

class TelegramMessage(BaseModel):
    update_id: int
    message: dict = None

async def send_message(chat_id, text):
    async with httpx.AsyncClient() as client_http:
        await client_http.post(f"{TELEGRAM_API}/sendMessage", json={
            "chat_id": chat_id,
            "text": text,
            "parse_mode": "Markdown"
        })

async def update_bot_commands():
    commands = [
        {"command": "start", "description": "–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"},
        {"command": "sub", "description": "–ü–æ–¥–ø–∏—Å–∫–∞"},
        {"command": "help", "description": "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è"},
        {"command": "admin", "description": "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞)"}
    ]
    async with httpx.AsyncClient() as client_http:
        await client_http.post(f"{TELEGRAM_API}/setMyCommands", json={"commands": commands})

def get_latest_news():
    params = {
        "q": "–Ω–æ–≤–æ—Å—Ç–∏",
        "hl": "ru",
        "gl": "ru",
        "api_key": SERPAPI_KEY
    }
    search = GoogleSearch(params)
    results = search.get_dict()
    news_results = results.get("news_results", [])
    if not news_results:
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–≤–µ–∂–∏–µ –Ω–æ–≤–æ—Å—Ç–∏."
    headlines = [f"‚Ä¢ {item['title']}" for item in news_results[:5]]
    return "\n".join(headlines)

async def generate_dalle(prompt):
    response = client.images.generate(
        model="dall-e-3",
        prompt=prompt,
        n=1,
        size="1024x1024"
    )
    return response.data[0].url

async def check_subscription(chat_id):
    row = await database.fetch_one("""
        SELECT is_active, expires_at FROM subscriptions WHERE chat_id = :chat_id
    """, {"chat_id": str(chat_id)})
    if row and row["is_active"] and row["expires_at"]:
        return row["expires_at"] > datetime.now(timezone.utc)
    return False

@app.post("/cloudpayments")
async def cloudpayments_webhook(request: Request):
    data = await request.json()
    provided_signature = request.headers.get("Content-HMAC")
    calculated_signature = hmac.new(CLOUDPAYMENTS_SECRET.encode(), request.body, hashlib.sha256).hexdigest()

    if not hmac.compare_digest(provided_signature, calculated_signature):
        return {"code": 13, "message": "Invalid signature"}

    chat_id = data.get("AccountId")
    transaction_id = data.get("TransactionId")
    payment_method = data.get("PaymentMethod")
    expires = datetime.now(timezone.utc).replace(microsecond=0) + timedelta(days=30)

    await database.execute("""
        INSERT INTO subscriptions (chat_id, is_active, expires_at, transaction_id, payment_method)
        VALUES (:chat_id, true, :expires, :transaction_id, :payment_method)
        ON CONFLICT (chat_id) DO UPDATE
        SET is_active = true, expires_at = :expires, transaction_id = :transaction_id, payment_method = :payment_method;
    """, {
        "chat_id": chat_id,
        "expires": expires,
        "transaction_id": transaction_id,
        "payment_method": payment_method
    })

    return {"code": 0, "message": "OK"}

@app.post("/webhook")
async def telegram_webhook(req: Request):
    body = await req.json()
    update = TelegramMessage(**body)

    if not update.message:
        return {"ok": True}

    try:
        msg = update.message
        chat_id = msg["chat"]["id"]
        text = msg.get("text", "").strip()

        await database.execute("""
            INSERT INTO users (chat_id) VALUES (:chat_id)
            ON CONFLICT (chat_id) DO NOTHING;
        """, {"chat_id": str(chat_id)})

        if text.startswith("/start"):
            await update_bot_commands()
            await send_message(chat_id,
                """üëã –ü—Ä–∏–≤–µ—Ç, —è BEST FRIEND ü§ñ ‚Äî —è —Ç–≤–æ–π –ª–∏—á–Ω—ã–π –ò–ò, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∏—â–µ—Ç –≤ —Ç–µ–±–µ –≤—ã–≥–æ–¥—É, –Ω–µ —É–≥–æ–≤–∞—Ä–∏–≤–∞–µ—Ç, –Ω–µ –ª—å—Å—Ç–∏—Ç.

üéì –ó–∞–º–µ–Ω—è—é –ª—é–±—ã–µ –ø–ª–∞—Ç–Ω—ã–µ –∫—É—Ä—Å—ã.
üß† –û—Ç–≤–µ—á–∞—é –∫–∞–∫ GPT-4.
üé® –†–∏—Å—É—é –∫–∞—Ä—Ç–∏–Ω–∫–∏.
üé• –°–∫–æ—Ä–æ ‚Äî –≤–∏–¥–µ–æ.

üÜì 3 –∑–∞–ø—Ä–æ—Å–∞ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ.
üí≥ –ü–æ–¥–ø–∏—Å–∫–∞: 399‚ÇΩ/–º–µ—Å –∏–ª–∏ 2990‚ÇΩ/–≥–æ–¥.

–ù–∞—á–Ω–∏ —Å –ª—é–±–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –Ø —É–∂–µ –∂–¥—É."""
            )
            return {"ok": True}

        if text.startswith("/sub"):
            await send_message(chat_id,
                "üí≥ –ü–æ–¥–ø–∏—Å–∫–∞: 399‚ÇΩ –≤ –º–µ—Å—è—Ü –∏–ª–∏ 2990‚ÇΩ –≤ –≥–æ–¥.\n\n–ü–∏—à–∏ \"–ø–æ–¥–ø–∏—Å–∫–∞\" –∏–ª–∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É (–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ), —á—Ç–æ–±—ã –æ—Ñ–æ—Ä–º–∏—Ç—å."
            )
            return {"ok": True}

        if text.startswith("/help"):
            await send_message(chat_id,
                "üìñ –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏, —á—Ç–æ —Ö–æ—á–µ—à—å: –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å, –ø–æ–ø—Ä–æ—Å–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, —É—Ç–æ—á–Ω–∏ –Ω–æ–≤–æ—Å—Ç–∏.\n\n–Ø –≤—Å—ë –ø–æ–π–º—É!"
            )
            return {"ok": True}

        if text.startswith("/admin") and str(chat_id) == "520740282":
            user_count = await database.fetch_val("SELECT COUNT(*) FROM users")
            subs_count = await database.fetch_val("SELECT COUNT(*) FROM subscriptions WHERE is_active = true")
            usage_count = await database.fetch_val("SELECT COUNT(*) FROM usage_log")
            await send_message(chat_id, f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {user_count}\nüí≥ –ü–æ–¥–ø–∏—Å–æ–∫: {subs_count}\nüìä –ó–∞–ø—Ä–æ—Å–æ–≤: {usage_count}")
            return {"ok": True}

        user_id = str(chat_id)
        is_owner = user_id == "520740282"
        is_subscribed = await check_subscription(user_id)

        if not is_owner and not is_subscribed:
            usage_key = f"user_usage:{user_id}"
            count = usage_counter.get(usage_key, 0)
            if count >= 3:
                await send_message(chat_id, "‚ùå –õ–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω. 3 –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥–µ–Ω—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ.\n\n–û—Ñ–æ—Ä–º–∏ –ø–æ–¥–ø–∏—Å–∫—É –∑–∞ 399‚ÇΩ –∏ –ø–æ–ª—å–∑—É–π—Å—è –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π.")
                return {"ok": True}
            usage_counter[usage_key] = count + 1

        await database.execute("""
            INSERT INTO usage_log (chat_id) VALUES (:chat_id)
        """, {"chat_id": user_id})

        if any(kw in text.lower() for kw in ["–Ω–∞—Ä–∏—Å—É–π", "—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π", "—Å–¥–µ–ª–∞–π –∫–∞—Ä—Ç–∏–Ω–∫—É", "–ø–æ–∫–∞–∂–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "—Ñ–æ—Ç–æ", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"]):
            image_url = await generate_dalle(text)
            async with httpx.AsyncClient() as client_http:
                await client_http.post(f"{TELEGRAM_API}/sendPhoto", json={"chat_id": chat_id, "photo": image_url})
            return {"ok": True}

        if "—á—Ç–æ –Ω–æ–≤–æ–≥–æ" in text.lower() or "–Ω–æ–≤–æ—Å—Ç–∏" in text.lower():
            news = get_latest_news()
            await send_message(chat_id, news)
            return {"ok": True}

        thread = client.beta.threads.create()
        client.beta.threads.messages.create(
            thread_id=thread.id,
            role="user",
            content=text
        )

        run = client.beta.threads.runs.create(
            thread_id=thread.id,
            assistant_id=ASSISTANT_ID
        )

        while True:
            run_status = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
            if run_status.status == "completed":
                break

        messages = client.beta.threads.messages.list(thread_id=thread.id)
        reply = messages.data[0].content[0].text.value
        await send_message(chat_id, reply)

    except Exception as e:
        await send_message(chat_id, f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {str(e)}")

    return {"ok": True}













